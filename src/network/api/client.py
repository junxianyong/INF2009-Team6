import inspect
import logging
import os
import threading
import urllib.request
from datetime import datetime
from pathlib import Path

from utils.logger_mixin import LoggerMixin


class UpdateDownloader(threading.Thread, LoggerMixin):
    """
    Handles downloading multiple updates concurrently, with callback support and logging.

    This class is designed to manage downloading updates from multiple URLs in parallel
    using threads. It provides logging for its operations at various levels and supports
    an optional callback to be executed after all downloads are completed. The underlying
    logic ensures thread safety and performs appropriate error handling during download
    operations.

    :ivar _downloads: Dictionary containing update types as keys and URLs as values.
                      This attribute holds updates that need to be downloaded.
    :type _downloads: dict
    :ivar _save_dir: Directory path where downloaded files are saved.
    :type _save_dir: str
    :ivar _callback: Optional callback function that gets triggered upon download
                     completion. The function can optionally accept one or two
                     parameters (indicating success and results).
    :type _callback: callable or None
    :ivar _results: Dictionary that stores the results of each download operation,
                    where keys are update types and values are boolean indicators
                    of success.
    :type _results: dict
    :ivar _logger: Logger instance configured for this class to handle logging output.
    :type _logger: logging.Logger
    """

    def __init__(self, downloads, save_dir, callback=None, logging_level=logging.INFO):
        """
        Initializes the `ThreadedDownloader` class to download multiple files in a separate thread.

        This class is designed to inherit from the `threading.Thread` class, making it possible
        to handle multiple file downloads concurrently. It allows you to provide custom callback
        functions and logging levels for tracking download progress. Internal states for downloads,
        save directory, and results are encapsulated as private attributes, ensuring encapsulation
        and proper operation. Additionally, logging is configured to provide detailed information
        about the download process.

        :param downloads: Dictionary containing update types as keys and URLs as values.
        :type downloads: Dict[str, str]
        :param save_dir: Directory path where downloaded files will be stored.
        :type save_dir: str
        :param callback: A callable function to handle the completion of a download. Optional.
                         If not provided, no callback will be executed.
        :type callback: callable, optional
        :param logging_level: Defines the level of logging. Default is logging.INFO.
                              This controls the verbosity of logs generated by the downloader.
        :type logging_level: int
        """
        threading.Thread.__init__(self)
        self._downloads = downloads
        self._save_dir = save_dir
        self._callback = callback
        self._results = {}

        # Configure logging
        self._logger = self.setup_logger(__name__, logging_level)

    def _call_callback(self):  # already private, correct
        """
        Executes a previously set callback function with appropriate parameters, based
        on the number of arguments the callback accepts. This utility function checks
        if a callback is set, determines the parameters expected by the callback, and
        automatically handles passing the correct arguments. Execution is logged for
        debugging purposes.

        :raises TypeError: If the callback function requires an unexpected number of
            arguments that is neither one nor two.
        :raises Any: Any error raised by the callback function during its execution
            will propagate.
        :rtype: None
        """
        if not self._callback:
            return

        # Check number of parameters the callback accepts
        params = inspect.signature(self._callback).parameters
        success = all(self._results.values())
        self._logger.debug(f"Callback triggered with success={success}")
        if len(params) == 1:
            self._callback(success)
        else:
            self._callback(success, self._results)

    def _download_file(
            self, update_type, url
    ):  # make private as it's an internal helper
        """
        Downloads a file from a given URL and saves it in the designated directory. This is
        an internal helper method used for fetching update files. The method logs its process
        to provide insights into each step of the operation, including directory creation,
        filename generation, and HTTP request handling. If an error occurs during the download,
        the method logs it and returns a failure state.

        :param update_type: The type of update being downloaded (e.g., "firmware", "software").
        :type update_type: str
        :param url: The URL from which the file will be downloaded.
        :type url: str
        :return: A boolean value indicating whether the file was successfully downloaded.
        :rtype: bool
        """
        try:
            self._logger.info(f"Starting download for {update_type} from {url}")

            # Create save directory if it doesn't exist
            Path(self._save_dir).mkdir(parents=True, exist_ok=True)
            self._logger.debug(f"Save directory ensured: {self._save_dir}")

            # Extract filename from URL
            filename = os.path.basename(urllib.parse.urlparse(url).path)
            if not filename:
                timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
                filename = f"{update_type}_{timestamp}"
                self._logger.debug(f"Generated filename: {filename}")

            # Combine directory path with filename
            full_path = os.path.join(self._save_dir, filename)
            self._logger.debug(f"Full save path: {full_path}")

            # Create request with headers
            headers = {
                "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36"
            }
            request = urllib.request.Request(url, headers=headers)

            # Download and save file
            with urllib.request.urlopen(request) as response:
                self._logger.debug(f"Connection established, downloading file")
                with open(full_path, "wb") as f:
                    f.write(response.read())

            self._logger.info(
                f"Successfully downloaded {update_type} update to {full_path}"
            )
            return True
        except Exception as e:
            self._logger.error(f"Failed to download {update_type} update: {str(e)}")
            return False

    def run(self):  # public as it's part of Thread interface
        """
        Starts and manages multiple download threads for updates and executes a callback
        upon completion.

        This method initializes download threads for each item in the `_downloads`
        dictionary. Each thread downloads a file and updates the `_results` attribute
        with the result of the download. The method waits for all threads to complete
        before triggering a callback function to indicate the process is finished.

        :param self: Represents the instance of the class containing this method.
        :raises KeyError: If keys used to access `_downloads` or `_results` do not exist.
        :raises RuntimeError: If a thread fails to start or join properly.

        :return: None
        """
        self._logger.info(
            f"Starting download threads for {len(self._downloads)} updates"
        )
        threads = []
        for update_type, url in self._downloads.items():
            thread = threading.Thread(
                target=lambda t=update_type, u=url: self._results.update(
                    {t: self._download_file(t, u)}
                )
            )
            thread.start()
            threads.append(thread)
            self._logger.debug(f"Started download thread for {update_type}")

        # Wait for all downloads to complete
        for thread in threads:
            thread.join()

        self._logger.info("All download threads completed")
        self._call_callback()
